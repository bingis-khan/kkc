use Slice
	Slice
	subslice
use Error
	panic
use Iter
	IntoIter
	into-iter
	zip
	from
	for-each
	drop
use Alloc
	Allocator
	allocate
use Str
	Str
	print-str
 
List alloc a
	al alloc
	elements Slice a  # elements.count ~ capacity
	count Int

fn get-ptr (list Ptr (List alloc a), i Int) -> Ptr a
	if i < 0 or i >= list&.count
		panic('Access to list at index \(i) (count: \(list&.count))')

	return Slice.get-ptr(list&.elements, i)

fn get (list Ptr (List alloc a), i Int) -> a:
	list get-ptr(i)&

fn set (list Ptr (List alloc a), i Int, elem a) -> Unit
	if i < 0 or i >= list&.count
		panic('Tried setting a list element at index \(i) (count: \(list&.count))')

	Slice.set(list&.elements, i, elem)
	# i guess i can also return the old value here.



inst IntoIter List
	into-iter (self):
		self.elements

		# just create a subslice with the required capacity and iterate.
		subslice(0, self.count)
		into-iter()



# kek, should be `new`, but I'm trying out a new convention.
fn mk (al alloc) -> List alloc a
	elements = Slice.empty()
	return List { al, elements, count: 0 }

fn free (list Ptr (List alloc a)) -> Unit <= Allocator alloc
	list&.al Alloc.free(list&.elements)
	return



starting-size = 8
growth-factor = 2
shrink-factor = 8

fn grow-if-full (list Ptr (List alloc a)) -> Unit <= Allocator alloc
	# check if the list is empty
	if list&.count == 0
		list <&.elements= list&.al allocate(starting-size)

	# resize it
	elif list&.count == list&.elements.count
		new-slice = list&.al allocate(list&.count * growth-factor)

		# NOTE: a lot of this stuff would be better with memmove/memcpy and realloc, but i want to minimize external dependencies as much as possible
		# still, the external interface and usage needs some contemplation
		# copy to old slice
		list&.elements zip(from(0)) for-each(fn Tuple2(x, i): Slice.set(new-slice, i, x))
		list&.al Alloc.free(list&.elements)
		list <&.elements= new-slice

fn add (list Ptr (List alloc a), elem a) -> Unit <= Allocator alloc
	list grow-if-full()
	Slice.set(list&.elements, list&.count, elem)
	list <&.count= list&.count + 1

fn insert (list Ptr (List alloc a), i Int, elem a) -> Unit <= Allocator alloc
	if i < 0 or i > list&.count
		panic('Insertion at list index \(i) (count: \(list&.count))')

	list grow-if-full()
	# move elements back
	# (maybe should use a reversed list iterator?)
	ii = list&.count - 1  # (grow-if-full ensures that ii + 1 will be okay)
	while ii >= i
		list&.elements Slice.set(ii + 1, list get(ii))
		ii <= ii - 1

	list&.elements Slice.set(i, elem)
	list <&.count= list&.count + 1


fn remove (list Ptr (List alloc a), i Int) -> Unit <= Allocator alloc
	if i < 0 or i >= list&.count
		panic('Removal at list index \(i) (count: \(list&.count))')

	# move elements back
	list&
		zip(from(0))
		drop(i + 1)
		for-each(fn Tuple2(elem, n): set(list, n - 1, elem))  # pointlessly complex to stress-test the compiler.

	list <&.count= list&.count - 1

	# optionally shrink it
	capacity = list&.elements.count
	if list&.count * shrink-factor < capacity
		if list&.count == 0
			list&.al Alloc.free(list&.elements)
			list <&.elements= Slice.empty()
			return

		new-size = (list&.count / shrink-factor + 1) * shrink-factor  # a multiple of shrink factor yo
		new-slice = list&.al allocate(new-size)
		list&.elements
			Slice.subslice(0, list&.count)
			Slice.copy-to(new-slice)

		list&.al Alloc.free(list&.elements)
		list <&.elements= new-slice

	return



inst Str List
	print-str (self)
		self.elements Slice.subslice(0, self.count) print-str()


# more misc functions that build upon the previous ones.
fn first (list)
	if list&.count == 0
		return None
	else
		return list get(0) Just()

fn pop (list): remove(list, list&.count - 1)
fn top (list)
	if list&.count == 0
		return None
	else
		return Just(list get(list&.count - 1))

fn add-all(list, it)
	it for-each(fn x: list add(x))

fn to-list(it, al)
	l =& mk(al)
	l add-all(it)
	return l&

fn to-slice(l)
	ptr = l.elements.ptr
	return Slice { ptr, count: l.count  }

fn addresses (l): l
	to-slice()
	Slice.addresses()
