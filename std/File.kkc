use Cnile
use Mem
use Alloc
	allocate
use Slice
	Slice
use Str
	chars
use DynStr
	DynStr
use Error
	or-fail
	unreachable
	panic
use Iter
	next

# TODO: make filename a general string
fn try-read-contents (al, filename)
	file = Cnile.fopen(filename, 'r')
	if file == Mem.null-ptr()
		return None

	Cnile.fseek(file, 0, Cnile.seek-end())
	file-size = Cnile.ftell(file)
	Cnile.fseek(file, 0, Cnile.seek-set())

	file-buf = al allocate(file-size + 1) as Slice Cnile.Char

	Cnile.fread(file-buf.ptr, 1, file-size, file)
	file-buf Slice.set(file-size, Mem.cast(0))

	Cnile.fclose(file)

	str = DynStr { contents: file-buf }
	return Just(str)


fn read-contents (al, filename):
	try-read-contents(al, filename) or-fail('could not open file \(filename)!')


fn try-write-contents (filename, contents) -> Bool
	file = Cnile.fopen(filename, 'w')
	if file == Mem.null-ptr()
		return False

	# oh no, this is soooo bad.
	it = contents chars()
	while True
		case next(&it)
			None
				# ughh.... write the file char-by-char............
				file Cnile.fclose()
				return True
			Just(c)
				chars-written = Cnile.fprintf1(file, '%c', c)
				if chars-written < 0
					return False

	return unreachable()



fn write-contents (filename, contents)
	if not try-write-contents(filename, contents)
		panic('could not write to file \(filename)')
