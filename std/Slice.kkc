use Term
use Mem
	offset-ptr
use Error
	or-fail
	panic
use Iter
	IntoIter
	Iter
	for-each
	from
	zip
use Str
	Str
	print-str


Slice a
	ptr Ptr a
	count Int

fn empty ():
	Slice { ptr: Mem.null-ptr(), count: 0 }


fn elem-size-of (slice Slice a):
	slice.ptr Mem.ptr-size-of()


fn get-ptr (slice Slice a, i Int) -> Ptr a
	if i < 0 or i >= slice.count
		panic('Access to slice at index \(i). (max: \(slice.count))')

	elem-ptr = slice.ptr Mem.offset-ptr(i)
	return elem-ptr

fn try-get (slice Slice a, i Int) -> Maybe a
	if i < 0 or i >= slice.count
		return None
	elem-ptr = slice.ptr Mem.offset-ptr(i)
	return Just(elem-ptr&)

fn get (slice Slice a, i Int) -> a:
	slice
	try-get(i)
	or-fail('Access to slice at index \(i). (max: \(slice.count))')

fn set (slice Slice a, i Int, x a)
	ep = slice get-ptr(i)
	ep <&= x


fn subslice (slice Slice a, from Int, to Int) -> Slice a
	if from > slice.count or to > slice.count
		panic('tried to sublice [\(from):\(to)], but slice has \(slice.count) elements')
	

	begin-ptr = slice.ptr Mem.offset-ptr(from)
	count = to - from
	if count < 0
		count <= 0

	return Slice { ptr: begin-ptr, count: count }



SliceIter a
	slice Slice a
	current-offset Int

inst IntoIter Slice
	into-iter (self):
		SliceIter { slice: self, current-offset: 0 }

inst IntoIter SliceIter
	into-iter (self): self

inst Iter SliceIter
	next (self Ptr (SliceIter a)) -> Maybe a
		off = self&.current-offset
		if off + 1 > self&.slice.count
			return None

		elem = self&.slice.ptr offset-ptr(off)&
		self <&.current-offset= off + 1
		return Just(elem)


# SHITTY STR INST (Item = Cnile.Char)
inst Str SliceIter
	print-str (self)
		self for-each(print-str)

	chars (self): self


SliceAddressIter a
	slice Slice a
	current-offset Int


fn addresses (slice Slice a):
	SliceAddressIter { slice: slice, current-offset: 0 }


inst IntoIter SliceAddressIter
	into-iter (self): self

inst Iter SliceAddressIter
	next (self Ptr (SliceAddressIter a)) -> Maybe (Ptr a)
		off = self&.current-offset
		if off + 1 > self&.slice.count
			return None

		elem = self&.slice.ptr offset-ptr(off)
		self <&.current-offset= off + 1
		return Just(elem)


fn copy-to (src Slice a, dest Slice a) -> Unit
	if src.count > dest.count
		panic('cannot copy to a slice that is smaller! (copying from \(src.count)-element slice to \(dest.count)-element slice)')

	src zip(Iter.from(0)) for-each(fn Tuple2(elem, i): set(dest, i, elem))


inst Str Slice
	print-str (self): self
		Str.print-as-list()

	chars (self): Error.todo()


inst ListDecon Slice
	deconstruct (self, lp, lc, spread, rp, rc)
		if lc > 0
			if lc > self.count
				return False

			lp <&= self.ptr

		if rc > 0
			if rc + lc > self.count
				return False

			cut = self
				subslice(self.count - rc, self.count)

			rp <&= cut.ptr

		case spread
			NoSpread
				return lc + rc == self.count

			UnassignedSpread
				return True

			AssignedSpread(xptr)
				xptr <&= self
					subslice(lc, self.count - rc)
				return True
