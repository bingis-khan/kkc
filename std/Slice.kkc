use Term
use Mem
	offset-ptr
use Error
	or-fail
use Iter
	IntoIter
	Iter
	for-each
	from
use Str
	Str
	print-str


Slice a
	ptr Ptr a
	count Int

fn empty ():
	Slice { ptr: Mem.null-ptr(), count: 0 }


fn elem-size-of (slice Slice a):
	slice.ptr Mem.ptr-size-of()


fn get-ptr (slice Slice a, i Int) -> Ptr a
	if i < 0 or i >= slice.count
		Error.critical('Access to slice at index \(i). (max: \(slice.count))')

	elem-ptr = slice.ptr Mem.offset-ptr(i)
	return elem-ptr

fn try-get (slice Slice a, i Int) -> Maybe a
	if i < 0 or i >= slice.count
		return None
	elem-ptr = slice.ptr Mem.offset-ptr(i)
	return Just(elem-ptr&)

fn get (slice Slice a, i Int) -> a:
	slice
	try-get(i)
	or-fail('Access to slice at index \(i). (max: \(slice.count))')

fn set (slice Slice a, i Int, x a)
	ep = slice get-ptr(i)
	ep <&= x


fn subslice (slice Slice a, from Int, to Int) -> Slice a
	if from > slice.count or to > slice.count
		Error.critical('tried to sublice [\(from):\(to)], but slice has \(slice.count) elements')
	

	begin-ptr = slice.ptr Mem.offset-ptr(from)
	count = to - from
	if count < 0
		count <= 0

	return Slice { ptr: begin-ptr, count: count }



SliceIter a
	slice Slice a
	current-offset Int

inst IntoIter Slice
	into-iter (self):
		SliceIter { slice: self, current-offset: 0 }

inst IntoIter SliceIter
	into-iter (self): self

inst Iter SliceIter
	next (self Ptr (SliceIter a)) -> Maybe a
		off = self&.current-offset
		if off + 1 > self&.slice.count
			return None

		elem = self&.slice.ptr offset-ptr(off)&
		self <&.current-offset= off + 1
		return Just(elem)



SliceAddressIter a
	slice Slice a
	current-offset Int


fn addresses (slice Slice a):
	SliceAddressIter { slice: slice, current-offset: 0 }


inst IntoIter SliceAddressIter
	into-iter (self): self

inst Iter SliceAddressIter
	next (self Ptr (SliceAddressIter a)) -> Maybe (Ptr a)
		off = self&.current-offset
		if off + 1 > self&.slice.count
			return None

		elem = self&.slice.ptr offset-ptr(off)
		self <&.current-offset= off + 1
		return Just(elem)


# fn copy-to (src Slice a, dest Slice a) -> Unit
# 	if src.count > dest.count
# 		Error.critical('cannot copy to a slice that is smaller! (copying from \(src.count)-element slice to \(dest.count)-element slice)')

# 	src zip(Iter.from(0)) for-each(fn Tuple2(elem, i): set(dest, i, elem))


inst Str Slice
	print-str (self)
		if self.count == 0
			print-str('[]')
		elif self.count == 1
			one-elem = get(self, 0)
			print-str('[\(one-elem)]')
		else
			print-str('[')
			print-str(get(self, 0))
			self
				subslice(1, self.count)
				for-each(fn elem: print-str(', \(elem)'))

			print-str(']')


