use Iter
	Iter
	IntoIter
	into-iter
	all
	reduce
use Str
	Str
	print-str
	chars
use Iter
	head
	count
	zip
	from
	for-each
	drop-while'
use Error
	panic
use Alloc
use Slice
use Mem
use DynStr
	DynStr
	substr


##### F64 crap yooo

F64StrIter
	buf Array 32 Char  # seems to be max possible?
	i Int

inst IntoIter Float
	into-iter (f)
		buf =& @undefined as Array 32 Char
		p = Mem.cast(buf) as Ptr Char
		Cnile.snprintf1(p, 32, '%g', f)
		return F64StrIter { buf: buf&, i: 0 }

inst IntoIter F64StrIter
	into-iter (self): self

inst Iter F64StrIter
	next (self) -> Maybe Char
		buf = &self&.buf
		c = buf Array.get(self&.i)
		if c == '\0'
			return None
		self <&.i= self&.i + 1
		return c Just()

inst Str Float
	print-str (self)
		Cnile.printf1('%g', self)

	chars (self): self into-iter()


##### Functions
# BUG: does not work for nullchars (due to our string representation still lacking length)
fn allocate-str (s, al) -> ConstStr
	len = s chars() count()
	str = al Alloc.allocate(len + 1)
	s chars()
		zip(from(0))
		for-each(fn Tuple2(c, i): str Slice.set(i, c))

	str Slice.set(len, Str.nullchar())
	return str.ptr Mem.cast()

fn newline() -> Char: '\n'

fn is-whitespace (c):
	c == ' ' or c == '\n' or c == '\t'

fn is-blank (s): s
	chars()
	all(is-whitespace)

#### Instances

LineIter
	og DynStr
	last Int

fn lines (s DynStr): LineIter { og: s, last: 0 }

inst IntoIter LineIter
	into-iter (self LineIter): self



inst Iter LineIter
	next (self Ptr LineIter) -> Maybe DynStr
		# should consume the last trailing newline
		if self&.last >= self&.og.contents.count or self&.og.contents Slice.get(self&.last) == Str.nullchar()
			return None

		# iterator is left after last encountered newline
		i = self&.last
		while not (self&.og.contents Slice.get(i) == newline() and i < self&.og.contents.count)
			i <= i + 1

		line = self&.og substr(self&.last, i)
		i <= i + 1  # skip past the newline

		# modify the state
		self <&.last= i

		return Just(line)



SplitWhitespaceIter it
	it it
	# TODO: in the future, add custom separator function.

fn split(it)
	it = it into-iter()
	it = it drop-while'(is-whitespace)
	return SplitWhitespaceIter { it }

inst IntoIter SplitWhitespaceIter
	into-iter (self): self

inst Iter SplitWhitespaceIter
	next (self Ptr (SplitWhitespaceIter it)) <= Iter it, IntoIter it
		if self&.it Iter.null()
			return None

		itAndTaken = self&.it Iter.take-while'(fn x: not x is-whitespace())
		case itAndTaken
			Tuple2(it, taken)
				self <&.it= it drop-while'(is-whitespace)
				return Just(taken)



###### Functions ######

# kekkekekekekkekekek
fn is-digit (c):
	Str.char-int(c) >= Str.char-int('0') and Str.char-int(c) <= Str.char-int('9')


fn parse-digit (c)
	if is-digit(c)
		return Just(Str.char-int(c) - Str.char-int('0'))
	else
		return None

fn parse-int(s)
	fn sequence-maybe (e, b)
		case b
			None
				return None
			Just(x)
				case parse-digit(e)
					None
						return None
					Just(xe)
						return Just(x * 10 + xe)

	return s chars() reduce(Just(0), sequence-maybe)
