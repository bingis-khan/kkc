
fn undefined(): @undefined
fn offset-ptr(x Ptr a, count Int):
	@offset-ptr(x, count * @size-of(@undefined as a))  # Alignment is already included in size, (as padding) so move should be okay?


TypeSize a
	size Int

fn get-typesize () -> TypeSize a
	return TypeSize { size: @size-of(@undefined as a) }

fn size-of (x a): @size-of(x)
fn ptr-size-of (x Ptr a): (get-typesize() as TypeSize a).size

# wrapper for intrinsic.
fn cast (x): @cast(x)

# safe cast for pointers
fn cast-ptr (p Ptr a) -> Ptr b: @cast(p)

# set a pointer if you're in a lambda :)
fn set-ptr(x Ptr a, e a)
	x <&= e


use Cnile
fn zeroed() -> a
	x = @undefined
	Cnile.memset(cast-ptr(&x), 0, size-of(x))
	return x

# make sure the second value's size is GREATER
fn cast-on-zeroed(x a) -> b
	y =& zeroed()
	yp = y cast()
	yp <&= x
	return y&

# TODO: maybe make a module "Ptr"?
# Also, this is only used for C shit... so this should not be here.
# For undefined stuff we should have 0xabcdef and stuff.
fn null-ptr() -> Ptr a: zeroed()
fn is-ptr-null(p Ptr a): @memeq(p, null-ptr())

fn ptr-to-int(p Ptr a) -> Int: @cast(p)
fn ptr-eq(l Ptr a, r Ptr a):
	@memeq(l, r)


fn from-nullable-c-str (s ConstStr)
	if s cast() ptr-eq (null-ptr() as Ptr Unit)
		return None
	else
		return Just(s)


