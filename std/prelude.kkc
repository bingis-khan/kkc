# absolute minimum. classes which the compiler depends on.


# void type
Unit
	Unit

#[ctype 'bool', cstdinclude 'stdbool.h']
Bool
	# #[clit 'false']
	False

	# #[clit 'true']
	True

#[ctype 'int']
Int

#[ctype 'float']
Float

#[ctype 'const char*']
ConstStr  # TODO: later, make a ptr + length struct string.


# stolen from Str std module. used in string interpolation
StrConcat l r
	StrConcat l r

StrCase c1 c2  # big hack for alternative string representations. (ex: Maybe)
	# honestly, we can just do the same thing as with iterators, where we define custom datatypes for this specific function.
	# But, I'll keep StrCase for now.
	StrCase1 c1
	StrCase2 c2

# #[ctype 'uint8_t', cstdinclude 'stdint.h']
# U8

# #[ctype 'int8_t', cstdinclude 'stdint.h']
# I8


# should ideally be shorthanded to: Ptr a: Ptr a
#[actual-pointer-type]
Ptr a
	Ptr a


# Index
# class Gettable
# 	# Key
# 	# Elem
# 	get (_, key key) -> elem


# List decostruction
ListSpread spread
	NoSpread
	UnassignedSpread
	AssignedSpread (Ptr spread)

class ListLike
	# Elem <- dependent type
	# correct type would be (_, Slice elem, Maybe (Maybe (Ptr _), Slice elem)), but the current one is easier to call from the iterpreter.
	deconstruct (self _, lp Ptr (Ptr elem), lc Int, spread ListSpread spread, rp Ptr (Ptr elem), rc Int) -> Bool


# this might be generated at compile time bruv. thats why im keeping it here.
# Also, instead of Tuple, Treeple, Quantuple use Tuple2, Tuple3, etc. It'll be easier to parse.
Tuple2 a b
	Tuple2 a b


Maybe a
	None
	Just a

Either e a
	Left e
	Right a
