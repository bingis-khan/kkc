# absolute minimum. classes which the compiler depends on.


# void type
Unit
	Unit

#[ctype 'bool', cstdinclude 'stdbool.h']
Bool
	# #[clit 'false']
	False

	# #[clit 'true']
	True

#[ctype 'int']
Int

# Is this too much voodoo? I'm basically only using it for Ints
# class Int <= Eq, Ord, Addition, Subtraction, Multiplication, Division

#[ctype 'float']
Float

#[ctype 'const char*']
ConstStr  # TODO: later, make a ptr + length struct string.

#[ctype 'char', bytes '1']
Char  # later change to RUNE!


# stolen from Str std module. used in string interpolation
StrConcat l r
	StrConcat l r

StrCase c1 c2  # big hack for alternative string representations. (ex: Maybe)
	# honestly, we can just do the same thing as with iterators, where we define custom datatypes for this specific function.
	# But, I'll keep StrCase for now.
	StrCase1 c1
	StrCase2 c2

# #[ctype 'uint8_t', cstdinclude 'stdint.h']
# U8

# #[ctype 'int8_t', cstdinclude 'stdint.h']
# I8


# should ideally be shorthanded to: Ptr a: Ptr a
#[actual-pointer-type]
Ptr a
	Ptr a

# my array type bruh
Array ^count a

# funny experiment-ahh class
class FromChar: Char
	from-charlike (s ConstStr) -> _

# maybe instead of ConstStr, we should have a special datatypes to signal a one-char string?


# Equality
class Eq
	eq (_, _) -> Bool

# Ord
Ordering
	LT
	EQ
	GT

class Ord
	cmp (_, _) -> Ordering


# numeric ops yooo
class Addition
	op-add (_, _) -> _

class Subtraction
	op-sub (_, _) -> _

class Multiplication
	op-mul (_, _) -> _

class Division
	op-div (_, _) -> _


# Index
class Gettable
	# Key
	# Elem
	get (_, key key) -> elem


# List construction (but actually Array bruhhhhhh)

# smol array type to seperate arrays that were created with an array literal.
# the only difference is that a smol array can be iterated over (since we know a user typed it out, so it's probably small, like a makefile dependency list)
SmolArray ^count a
	arr Array count a

class ListLike: SmolArray
	# type Elem
	# maybe take in pointer to it?
	from-listlike (arr Array count elem) -> _


# List decostruction
ListSpread spread
	NoSpread
	UnassignedSpread
	AssignedSpread (Ptr spread)

class ListDecon
	# Elem <- dependent type
	# correct type would be (_, Slice elem, Maybe (Maybe (Ptr _), Slice elem)), but the current one is easier to call from the iterpreter.
	deconstruct (self _, lp Ptr (Ptr elem), lc Int, spread ListSpread spread, rp Ptr (Ptr elem), rc Int) -> Bool


# Iter and IntoIter is directly used by `for .. in` loop.
Maybe a
	None
	Just a

class IntoIter
	into-iter (self _) -> itershit

class Iter
	next (self Ptr _) -> Maybe item


# this might be generated at compile time bruv. thats why im keeping it here.
# Also, instead of Tuple, Treeple, Quantuple use Tuple2, Tuple3, etc. It'll be easier to parse.
Tuple2 a b
	Tuple2 a b

# maybe they should not be here?
fn fst(Tuple2(l, _)): l
fn snd(Tuple2(_, r)): r



Either e a
	Left e
	Right a



##### INSTANCES !!!! #######

inst FromChar ConstStr
	from-charlike (s): s

inst FromChar Char
	from-charlike (s): (@cast(s) as Ptr Char)&


# Eq

inst Eq Int
	eq (l, r): @memeq(l, r)

inst Eq Bool
	eq (l, r): @memeq(l, r)

inst Eq Ordering
	eq (l, r): @memeq(l, r)

inst Eq Char
	eq (l, r): @memeq(l, r)

inst Eq Maybe
	eq (l, r)
		case Tuple2(l, r)
			Tuple2(None, None)
				return True

			Tuple2(Just(l), Just(r))
				return l == r

			_
				return False

inst Eq Ptr
	eq (Ptr(l), Ptr(r)): l == r


# ops

## Int

inst Addition Int
	op-add (l, r): @i64-add(l, r)

inst Subtraction Int
	op-sub (l, r): @i64-sub(l, r)

inst Multiplication Int
	op-mul (l, r): @i64-mul(l, r)

inst Division Int
	op-div (l, r): @i64-div(l, r)


## Float

inst Addition Float
	op-add (l, r): @f64-add(l, r)

inst Subtraction Float
	op-sub (l, r): @f64-sub(l, r)

inst Multiplication Float
	op-mul (l, r): @f64-mul(l, r)

inst Division Float
	op-div (l, r): @f64-div(l, r)


inst ListLike Array
	from-listlike (self): self

inst ListLike SmolArray
	from-listlike (arr): SmolArray { arr }
