class IntoIter
	into-iter (self _) -> itershit

class Iter
	next (self Ptr _) -> Maybe item


# Basic instances
inst IntoIter Ptr
	into-iter (self): self& into-iter()


# MAPPPP
Map it from to
	Map it (from -> to)

inst IntoIter Map
	into-iter (self Map it from to) -> Map it from to
		return self

inst Iter Map
	next (Ptr(Map(it, fun)))
		case next(&it)
			None
				return None
			Just(x)
				return Just(fun(x))


fn map (iterable, fun)
	it = into-iter(iterable)
	return Map(it, fun)


##### FILTERRRRRR
Filter it item
	og it
	fun item -> Bool


inst IntoIter Filter
	into-iter (self Filter it from) -> Filter it from
		return self

inst Iter Filter
	next (self Ptr (Filter it item)) -> Maybe item <= Iter it
		while True
			case next(&self&.og)
				None
					return None
				Just(x)
					if self&.fun(x)
						return Just(x)

		# unreachable
		return @undefined


fn filter (iterable it, fun from -> Bool) -> Filter it' from <= IntoIter it
	it = into-iter(iterable)
	return Filter { og: it, fun: fun }


# DROPPPP
Drop it
	Drop it Int

inst IntoIter Drop
	into-iter (self Drop it) -> Drop it: self

inst Iter Drop
	next (Ptr(Drop(it, i)))
		while i > 0
			_ = next(&it)
			i <= i - 1
		return next(&it)


fn drop (iterable, i)
	it = iterable into-iter()
	return Drop(it, i)


# Takeeee
Take it
	Take it Int

inst IntoIter Take
	into-iter(self): self

inst Iter Take
	next(Ptr(Take(it, i)))
		if i > 0
			x = next(&it)
			i <= i - 1
			return x
		else
			return None

fn take(it, i): Take(it into-iter(), i)


# Bounded range
Range
	Range Int Int

RangeIter
	RangeIter Range Int

fn to (from, to): Range(from, to)
fn range (from, to): Range(from, to)

inst IntoIter Range
	into-iter (Range(from, to)): RangeIter(Range(from, to), from)

inst IntoIter RangeIter
	into-iter (self RangeIter): self

inst Iter RangeIter
	next (self Ptr RangeIter) -> Maybe Int
		case self&
			RangeIter(Range(from, to), cur)
				if cur > to
					return None

				x = Just(cur)
				self <&= RangeIter(Range(from, to), cur + 1)
				return x





# Unbounded range
FromIter
	from Int

fn from(f): FromIter { from: f }

inst IntoIter FromIter
	into-iter(it): it

inst Iter FromIter
	next (Ptr(self) Ptr FromIter) -> Maybe Int
		v = self.from
		self <.from= self.from + 1
		return Just(v)

	
Zip it it'
	left-it it
	right-it it'


inst IntoIter Zip
	into-iter (self Zip it it'): self

inst Iter Zip
	next (self Ptr (Zip it it')) -> Maybe (Tuple2 item item') <= Iter it, Iter it'
		copy = self&  # kind of stupid but it works. we should not consume elements if we can't. i mean, the user should probably take care of his iter not having side effects. i guess.
		while True
			case next(&copy.left-it)
				None
					return None
				Just(left-x)
					case next(&copy.right-it)
						None
							return None
						Just(right-x)
							# consume the two (yeah, kinda funny)
							next(&self&.left-it)
							next(&self&.right-it)
							return Just(Tuple2(left-x, right-x))


fn zip(left, right)
	left-it = left into-iter()
	right-it = right into-iter()
	return Zip { left-it: left-it, right-it: right-it }



# consoomers

fn for-each (iterable, fun)
	it =& into-iter(iterable)
	while True
		case next(it)
			None
				return
			Just(x)
				_ = fun(x)


fn reduce (iterable it, base a, fun (item, a) -> a) -> a <= IntoIter it
	x = base
	it = into-iter(iterable)
	while True
		case next(&it)
			None
				return x
			Just(res)
				x <= fun(res, x)

	return @undefined  # unreachable. we need better return checking.

fn count(it it) -> Int <= IntoIter it:
	it reduce(0, fn (_, x): x + 1)

fn all(it, fun): it
	reduce(True, fn (e, x): fun(e) and x)

fn head(it): (&it into-iter()) next()
