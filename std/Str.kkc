use Cnile
use Iter
	Iter
	IntoIter
	into-iter
	next
	head
	zip
	all
	for-each
	Drop
	Take
	TakeWhile
use Mem
use Math

class Str
	# later should write to some buffer instead of printing directly.
	print-str (self _) -> Unit
	chars (self _) -> iter


##### ConstStr ######

ConstStrIter
	ogstr ConstStr
	i Int

inst IntoIter ConstStr
	into-iter (self): ConstStrIter { ogstr: self, i: 0 }

inst IntoIter ConstStrIter
	into-iter (self): self

inst Iter ConstStrIter
	next (self)
		if self&.i >= Cnile.strlen(self&.ogstr)  # later this will be good, when the default string will also have a length.
			return None

		char-ptr = Mem.cast(self&.ogstr) as Ptr Cnile.Char
		c = (char-ptr Mem.offset-ptr(self&.i))&
		self <&.i= self&.i + 1
		return Just(c)

inst Str ConstStr
	print-str (self _) -> Unit
		Cnile.printf1('%s', self)
	chars (self _) -> ConstStrIter:
		self into-iter()



inst Str Char
	print-str (self _) -> Unit
		Cnile.printf1('%c', self)

	chars (self _):
		Iter.single(self)



####### Int #######

IntStrIter
	int Int
	len Int

inst IntoIter IntStrIter
	into-iter(self): self

inst Iter IntStrIter
	next (self Ptr IntStrIter) -> Maybe Cnile.Char
		if self&.len <= 0
			return None

		trim-down = 10 Math.pow (self&.len - 1)
		upper = self&.int / trim-down
		upper-mask = (upper / 10) * 10
		digit = upper - upper-mask

		self <&.len= self&.len - 1

		digit-char = Mem.cast(digit + 48)
		return Just(digit-char)


# funny :)
fn count-digits (self Int) -> Int
	if self == 0
		return 1

	digits = 0
	while self > 0
		self <= self / 10
		digits <= digits + 1

	return digits

inst Str Int
	print-str (self Int) -> Unit
		Cnile.printf1('%ld', self)

	chars (self Int):
		IntStrIter { int: self, len: self count-digits() }



####### Others, non-polymorphic #######

inst Str Bool
	print-str (self Bool) -> Unit
		if self
			print-str('True')
		else
			print-str('False')

	chars (self)
		if self
			return 'True' chars()
		else
			return 'False' chars()

inst Str Unit
	print-str (self Unit) -> Unit
		print-str('()')

	chars (self): '()' chars()

inst Str Ordering
	print-str (self)
		case self
			LT
				print-str('LT')
			EQ
				print-str('EQ')
			GT
				print-str('GT')

	chars (self)
		case self
			LT
				return 'LT' chars()
			EQ
				return 'EQ' chars()
			GT
				return 'GT' chars()



######## StrConcat #########

StrConcatIter l r
	left l
	right r

inst IntoIter StrConcatIter
	into-iter (self): self

inst Iter StrConcatIter
	next (self)
		case next(&self&.left)
			Just(s)
				return Just(s)
			None
				return next(&self&.right)

inst IntoIter StrConcat
	into-iter (StrConcat(left, right)): StrConcatIter { left: left chars(), right: right chars() }

inst Str StrConcat
	print-str (self _) -> Unit
		case self
			StrConcat(l, r)
				print-str(l)
				print-str(r)

	chars (self): self into-iter()



####### StrCase #######

StrCaseIter c1 c2
	StrCaseIter1 c1
	StrCaseIter2 c2

inst IntoIter StrCaseIter
	into-iter(self): self

inst Iter StrCaseIter
	next(self)
		case self&
			StrCaseIter1(c)
				return next(&c)

			StrCaseIter2(c)
				return next(&c)
inst IntoIter StrCase
	into-iter (self)
		case self
			StrCase1(c)
				return StrCaseIter1(c chars())
			StrCase2(c)
				return StrCaseIter2(c chars())
inst Str StrCase
	print-str (self)
		case self
			StrCase1(c)
				c print-str()

			StrCase2(c)
				c print-str()

	chars (self): self into-iter()





inst Str Ptr
	print-str (self _)
		_ = print-str(self&)

	chars (self): self& chars()



inst Str Maybe
	print-str (self _)
		case self
			None
				print-str('None')

			Just(x)
				print-str('Just(\(x))')

	chars (self)
		c = @undefined
		case self
			None
				c <= 'None' StrCase1()

			Just(x)
				c <= 'Just(\(x))' StrCase2()

		return c chars()


inst Str Tuple2
	print-str (tup)
		case tup
			Tuple2(l, r)
				print-str('(\(l), \(r))')


##### Iterators (rn I've decided that treating strings as iterators should *just work*(TM)) (this MIGHT CHANGE IN THE FUTURE)

inst Str Take
	print-str (self)
		self for-each(print-str)

	chars (self): self
	
inst Str Drop
	# this is barely typed. Assumes Item = Char
	print-str (self)
		self for-each(print-str)

	chars (self): self

inst Str TakeWhile
	print-str (self)
		self for-each(print-str)

	chars (self): self


###### Functions ######

fn nullchar() -> Cnile.Char: Mem.zeroed()  # HACK!!
fn eq(l, r): l chars() zip(r chars()) all(fn Tuple2(lc, rc): lc == rc)  # this is incorrect, because we zip() trims!
fn streq(l, r): eq(l, r)
fn char-int(c Char) -> Int:
	Mem.cast-on-zeroed(c)

###### Other Instances #####

inst Eq ConstStr
	eq (l, r): Cnile.strcmp(l, r) == 0
