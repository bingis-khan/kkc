use Iter
	IntoIter
	Iter
	into-iter
	next
use Slice
	Slice

fn get-ptr (arr Ptr (Array count a), i Int) -> Ptr a
	if i < 0 or i >= count
		Error.panic('Access to array at index \(i). (max: \(count))')

	p = Mem.cast(arr) as Ptr a
	return Mem.offset-ptr(p, i)

fn get (arr Ptr (Array count a), i Int) -> a:
	arr get-ptr(i)&

fn set (arr Ptr (Array count a), i Int, e a)
	p = arr get-ptr(i)
	p <&= e


fn as-slice (arr Ptr (Array count a)) -> Slice a:
	Slice { ptr: Mem.cast(arr), count }


# ARRAY YAH
# It's here, because why not. It's still imported by default.

SmolArrayIter ^count a
	backing SmolArray count a
	cur Int

inst IntoIter SmolArray
	into-iter (self):
		SmolArrayIter { backing: self, cur: 0 }

inst IntoIter SmolArrayIter
	into-iter (self): self

inst Iter SmolArrayIter
	next (self Ptr (SmolArrayIter count a))
		if self&.cur >= count
			return None

		e = (&self&.backing.arr) get(self&.cur)
		self <&.cur= self&.cur + 1
		return Just(e)
