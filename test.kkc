use Cock

class Str
	print-str (self _)

inst Str Int
	print-str (self _)
		_ = printf1('%d', self)
		return

inst Str ConstStr
	print-str (self _)
		_ = printf1('%s', self)
		return


inst Str StrConcat
	print-str (self _)
		case self
			StrConcat(l, r)
				_ = print-str(l)
				_ = print-str(r)
				return

inst Str Ptr
	print-str (self _)
		_ = print-str(self&)
		return


fn println (s): print-str(StrConcat(s, '\n'))


class IntoIter
	into-iter (self _) -> itershit

class Iter
	next (self Ptr _) -> Maybe item

Map it from to
	Map it (from -> to)

inst IntoIter Map
	into-iter (self Map it from to) -> Map it from to
		return self

inst Iter Map
	next (self)
		case self&
			Map(it, fun)
				case next(&it)
					None
						return None
					Just(x)
						return Just(fun(x))


fn map (iterable, fun)
	it = into-iter(iterable)
	return Map(it, fun)


Range
	Range Int Int

RangeIter
	RangeIter Range Int

fn to (from, to): Range(from, to)
fn range (from, to): Range(from, to)

inst IntoIter Range
	into-iter (self)
		case self
			Range(from, to)
				return RangeIter(self, from)

inst IntoIter RangeIter
	into-iter (self RangeIter): self

inst Iter RangeIter
	next (self Ptr RangeIter) -> Maybe Int
		case self&
			RangeIter(Range(from, to), cur)
				if cur > to
					return None

				x = Just(cur)
				self <&= RangeIter(Range(from, to), cur + 1)
				return x


fn for-each (iterable, fun)
	it = into-iter(iterable)
	while True
		case next(&it)
			None
				return
			Just(x)
				_ = fun(x)

fn addn(m)
	fn add(x)
		return x + m
	return add

1 to (10) map(addn(1)) map(addn(3)) for-each(println)
x = 420
println('x\(x)x')
println(test-function-with-env-in-prelude())

Cock.cock()

fn unpack (mx)
	case mx
		Just(x)
			println('JUST!!! \(x)')

		None
			println('NONE!!!')

	return


fn mapMaybe (x, fun)
	case x
		Just(xx)
			return Just(fun(xx))
		None
			return None

Just(123123) mapMaybe(addn(429)) unpack()
None unpack()
