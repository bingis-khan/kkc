#!./zig-out/bin/kkc
use Term
use Slice
use Alloc
	allocate

Lazy a
	AlreadyEvald a
	ToEval (() -> a)

fn lazy-get (Ptr(l) Ptr (Lazy a)) -> a
	case l
		AlreadyEvald(x)
			return x
		ToEval(fnn)
			x = fnn()
			l <= AlreadyEvald(x)
			return x

fn lazy(fnn): ToEval(fnn)

fn miau()
	Term.println('miaaau')
	return 69

l =& lazy(miau)
ll =& lazy(:420)
l lazy-get() Term.println()
l lazy-get() Term.println()

1 to (5)
	for-each(fn(x): Term.println(x))


# inst Str Slice
# 	print-str (self)
# 		if self.count == 0
# 			print-str('[]')
# 		elif self.count == 1
# 			one-elem = get(self, 0)
# 			print-str('[\(one-elem)]')
# 		else
# 			print-str('[')
# 			print-str(get(self, 0))
# 			self
# 				subslice(1, self.count)
# 				for-each(elem: print-str(', \(elem)'))

# 			print-str(']')

# 	# i'll implement other stuff later...

# SliceAddressIter a
# 	slice Slice a
# 	current-offset Int


# fn addresses (slice Slice a):
# 	SliceAddressIter { slice, current-offset: 0 }


# inst IntoIter SliceAddressIter a
# 	into-iter (self): self

# inst Iter SliceAddressIter a
# 	next (self Ptr (SliceAddressIter a)) -> Maybe (Ptr a)
# 		off = self&.current-offset
# 		if off + 1 > self&.slice.count
# 			return None

# 		elem = self&.slice.ptr offset-ptr(off)
# 		self <&.current-offset= off + 1
# 		return Just(elem)



# fn copy-to (from Slice a, to Slice a) -> Unit
# 	if from.count > to.count
# 		Error.critical('cannot copy to a slice that is smaller! (copying from \(from.count)-element slice to \(to.count)-element slice)')

# 	from
# 		zip(Iter.from(0))
# 		for-each(uncurry((elem, i): set(to, i, elem)))
